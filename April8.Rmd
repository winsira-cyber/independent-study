---
title: "Visualization of Ovarian Cancer DATA using various R packages"
knit: (function(input_file, encoding) {
    out_dir<- 'docs';
    rmarkdown::render(input_file,
      encoding=encoding,
      output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
output: html_document
---

```{r}
library(curatedOvarianData) 
data(package="curatedOvarianData")
```

```{r}
data(TCGA_eset) 
# Get gene names
gene_names <- featureNames(TCGA_eset)
head(gene_names, 10)



```
The TCGA_eset dataset contains gene expression data for 13,104 features (genes) across 578 samples. The data has been preprocessed and normalized using a standardized pipeline to remove batch effects and other sources of technical variability. The resulting dataset contains 20,501 genes and is stored as an ExpressionSet object in R, which includes not only the gene expression data but also sample annotation information and other metadata.


## Extract metadata and clinical information:
we can access this information using the pData() and fData() functions from the Biobase package.

```{r}
summary(TCGA_eset)
dim(TCGA_eset)
#if (!requireNamespace("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")

#BiocManager::install("Biobase")

library(Biobase)
sample_metadata <- pData(TCGA_eset)
#head(sample_metadata)
feature_metadata <- fData(TCGA_eset)
#head(feature_metadata)
```



## Heatmaps 

```{r}

library(curatedOvarianData)
library(pheatmap)


# Extract gene expression data
exprs_matrix <- exprs(TCGA_eset)

# Set row names to gene names
rownames(exprs_matrix) <- featureNames(TCGA_eset)

# Subset to top 20 most variable genes by custom filter
exprs_matrix <- exprs_matrix[apply(exprs_matrix, 1, function(x) var(x) > 0.5), ][20:40, ]

# Create heatmap
pheatmap(exprs_matrix, scale = "row", clustering_distance_rows = "euclidean", show_rownames = T, show_colnames=F)

```
The plot shows a heatmap of the expression levels of the top 20 most variable genes (determined by a custom filter) in a subset of samples from the TCGA ovarian cancer dataset. Each row represents a gene, and each column represents a sample. The color scale represents the level of expression for each gene in each sample, with red indicating high expression and blue indicating low expression. The rows are clustered using euclidean distance and the columns are not clustered 


```{r}
library(ComplexHeatmap)

top_gene_expression <- exprs(TCGA_eset)
sample_metadata <- pData(TCGA_eset)
top_gene_expression_t <- t(top_gene_expression)
combined_data <- data.frame(Sample_Type = sample_metadata$sample_type, top_gene_expression_t)
#non_na_indices contain the indices of all samples that have a non-missing value
non_na_indices <- which(!is.na(sample_metadata$sample_type))
# we create a new data frame with the Sample_Type column, using only the rows corresponding to the non_na_indices.
sample_annotation_filtered <- data.frame(Sample_Type = sample_metadata$sample_type[non_na_indices])
rownames(sample_annotation_filtered) <- rownames(sample_metadata)[non_na_indices]
# filter the columns of the top_gene_expression matrix to include only those that correspond to the non_na_indices
top_gene_expression_filtered <- top_gene_expression[, non_na_indices]


```

```{r}
col_fun <- colorRampPalette(c("blue", "white", "red"))(100)

Heatmap(top_gene_expression_filtered,
        col = col_fun,
        name = "Expression",
        cluster_rows = TRUE,
        cluster_columns = TRUE,
        show_column_names = FALSE,
        show_row_names = FALSE,
        top_annotation = HeatmapAnnotation(df = sample_annotation_filtered$Sample_Type))

```
The heatmap is showing the gene expression levels for the top variable genes in the dataset, with rows representing genes and columns representing individual samples. The color scale represents the relative expression levels of the genes, with red indicating high expression and blue indicating low expression. The heatmap can be used to identify patterns of gene expression that distinguish between tumor and healthy samples.



## Correlation Plot 

```{r}
library(corrplot)
gene_expression <- exprs(TCGA_eset)
# Select a subset of genes (e.g., the first 20 genes)
selected_genes <- gene_expression[1:20, ]

# Select a subset of samples (e.g., the first 100 samples)
selected_samples <- selected_genes[, 1:100]

correlation_matrix_subset <- cor(t(selected_samples), method = "pearson")

corrplot(correlation_matrix_subset, method = "color", type = "upper", mar = c(0, 0, 1, 1))


```
This plot is showing the correlation between the expression levels of a subset of genes (the first 20 genes) in a subset of samples (the first 100 samples) from the TCGA_eset dataset. The plot is a correlation matrix, where each cell represents the correlation between the expression levels of two genes. The color of each cell indicates the strength of the correlation, with darker colors indicating stronger positive or negative correlations.

```{r}
library(corrplot)
gene_expression <- exprs(TCGA_eset)
# Select a subset of genes (e.g., the first 100 genes)
selected_genes <- gene_expression[1:100, ]

# Select a subset of samples (e.g., the first 100 samples)
selected_samples <- selected_genes[, 1:100]

correlation_matrix_subset <- cor(t(selected_samples), method = "pearson")

corrplot(correlation_matrix_subset, method = "color", type = "upper", mar = c(0, 0, 1, 1),tl.pos="n")


```


## Network analysis plots

```{r}
library(igraph)
# Load the TCGA_eset dataset
data(TCGA_eset)

# Extract the gene expression data
tcga.exprs <- exprs(TCGA_eset)
# Subset the gene expression data to the first 30 samples
tcga.exprs <- tcga.exprs[, 1:30]

# Log2 transformation of the gene expression data
log2.exprs <- log2(tcga.exprs + 1)

# Calculate the variance for each gene
gene.variance <- apply(log2.exprs, 1, var)

# Order genes by variance and select the top 100
top.genes <- head(order(gene.variance, decreasing = TRUE), 100)

# Subset the gene expression data with the top 50 genes
subset.exprs <- log2.exprs[top.genes, ]

# Generate a correlation matrix of the gene expression data
cor.matrix <- cor(subset.exprs)

# Create an igraph graph object
graph <- graph.adjacency(cor.matrix, mode = "undirected", weighted = TRUE)

# Set node color based on gene expression level
node.color <- ifelse(rowMeans(subset.exprs) > log2(6), "red", "blue")

# Plot the graph with node color based on gene expression level
plot(graph, vertex.size =8, vertex.color = node.color,vertex.label.cex = 0.7, edge.width = E(graph)$weight*2)



```


Each node represents a gene.The edges connecting the nodes represent the correlation between the expression levels of the connected genes. The edge width is proportional to the correlation strength.
The node color is determined by the average gene expression level. If the mean expression level is greater than log2(6), the node is colored red, otherwise, it's colored blue.
This plot can help  visualize and explore the relationships between the most variably expressed genes in the dataset. It can provide insights into the co-expression patterns, which can be useful for understanding gene function, regulation, and interactions. However, it's essential to keep in mind that correlation does not imply causation, and further analyses or experimental validation may be necessary to confirm the relationships between the genes.




## Volcano plot

```{r}
options(digits = 10)
library(limma)
# Create a design matrix using your sample group information

design <- model.matrix(~ 0 + sample_metadata$sample_type)

# the linear model is fit to the gene expression data using the sample metadata information to define groups
fit <- lmFit(TCGA_eset, design)

# empirical Bayes statistics are applied to obtain moderated t-statistics for each gene. 
#The moderated t-statistics are used to rank the genes based on differential expression between groups
fit <- eBayes(fit)
#summary(fit)

#topTable function is to extract the top genes based on this ranking
#adjust parameter is set to "fdr" to adjust the p-values for multiple testing using the false discovery rate method. 
#significance threshold is defined to identify the differentially expressed genes based on the adjusted p-value
results <- topTable(fit, number = nrow(TCGA_eset), adjust = "fdr", sort.by = "none")



head(results)
```

```{r}
options(digits = 4)
library(ggplot2)

# Prepare the data for the volcano plot
volcano_data <- data.frame(
  genes = results$gene,
  log2FoldChange = results$sample_metadata.sample_typetumor - results$sample_metadata.sample_typehealthy,
  pvalue = results$adj.P.Val,
  adj_pvalue = -log10(results$adj.P.Val) * sign(results$sample_metadata.sample_typetumor - results$sample_metadata.sample_typehealthy)
)

# Create the volcano plot
ggplot(volcano_data, aes(x = log2FoldChange, y = adj_pvalue)) +
  geom_point(aes(color = adj_pvalue > 0.05), alpha = 0.7) +
  scale_color_manual(values = c("blue", "red")) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  labs(x = "Log2 Fold Change", y = "-log10 adjusted p-value", title = "Differentially Expressed Genes") +
  theme_classic()

```
The volcano plot shows the log2 fold change in expression (x-axis) versus the negative log10 adjusted p-value (y-axis) for each gene. The blue points represent genes that are not significantly differentially expressed (adjusted p-value > 0.05), while the red points represent genes that are significantly differentially expressed (adjusted p-value < 0.05). The dashed horizontal line represents the threshold for statistical significance at an adjusted p-value of 0.05. T




## circlize 
The plot is constructed using the circlize package in R, which allows for circular visualization of network data. The color of the edges represents the superpathway of the first metabolite (numerator of the ratio) of the metabolite pair that constructs the metabolite ratios. The grayscale gradient filling the edges indicates the strength of the genetic association with darker color indicating stronger significance.
```{r}

library(affy)
library(circlize)

# Load the TCGA_eset dataset
data(TCGA_eset)

# Extract gene expression data
gene_expression <- exprs(TCGA_eset)

# Calculate variance for each gene
gene_variance <- apply(gene_expression, 1, var)

# Get the indices of the top 6 genes with the highest variance
top_genes <- order(gene_variance, decreasing = TRUE)[10:15]

# Randomly select 6 samples

selected_samples <-15:20

# Subset the gene expression data with the top 5 genes and the selected 10 samples
subset_exprs <- gene_expression[top_genes, selected_samples]
# Create the chord diagram
chordDiagram(subset_exprs)

# Set the font size of the labels
circos.text(0, seq(0, 1, by = 1/length(top_genes)), top_genes, 
            facing = 
              "outside", niceFacing = T, cex = 0.001, adj = c(-0.05, 0.05))



```


each segment of the circle represents a sample, and the thickness of the segment corresponds to the expression level of the selected genes for that sample. The segments are arranged in a circular layout and connected by ribbons, where the width of each ribbon represents the strength of the correlation between the two genes connected by the ribbon. 

## NetworkD3
```{r}

# Load necessary libraries
library(GEOquery)
library(networkD3)

# Download the GSE113690 dataset
gse <- getGEO("GSE113690")
eset <- gse[[1]]

# Extract gene expression data
exprs <- exprs(eset)

# Calculate variance for each gene
gene_variance <- apply(exprs, 1, var)

# Get the indices of the top 20 genes with the highest variance
top_genes <- head(order(gene_variance, decreasing = TRUE), 20)

# Randomly select 20 samples
set.seed(1)
selected_samples <- sample(ncol(exprs), 20)

# Subset the gene expression data with the top 20 genes and the selected 20 samples
subset_exprs <- exprs[top_genes, selected_samples]

# Calculate correlation matrix
cor_mat <- cor(subset_exprs)

# Convert correlation matrix to edge list
edge_list <- as.data.frame(as.table(cor_mat))
colnames(edge_list) <- c("source", "target", "weight")
# Define node colors and sizes
# Create the simple network

simpleNetwork(edge_list,linkColour = "blue")
            

```
This plot is showing a simple network diagram where nodes represent the top 20 genes with the highest variance and edges represent the correlation between them based on the subset of gene expression data. The thickness of the edges represents the strength of the correlation between the genes.

## networkvis
```{r}
library(visNetwork)
library(visNetwork)
set.seed(1)
# Create a data frame with nodes and edges
nodes <- data.frame(id = 1:10, 
                    label = paste0("Node ", 1:10), 
                    value = sample(1:10, 10, replace = TRUE),
                    color = c("red", "blue", "green", "orange", "purple", 
                              "yellow", "pink", "brown", "grey", "black"))
edges <- data.frame(from = sample(1:10, 20, replace = TRUE), 
                    to = sample(1:10, 20, replace = TRUE))

# Create the network visualization
visNetwork(nodes, edges) %>% 
  visOptions(highlightNearest = TRUE, 
             nodesIdSelection = TRUE) %>% 
  visLayout(randomSeed = 123)


```


```{r}
library(nycflights13)
library(visNetwork)
library(dplyr)


flights_subset <- flights %>%
  group_by(origin) %>%
  sample_n(size = 10)

# create nodes and edges data frames
nodes <- data.frame(id = unique(c(flights_subset$origin, flights_subset$dest)), 
                    label = unique(c(flights_subset$origin, flights_subset$dest)))
edges <- data.frame(from = flights_subset$origin, to = flights_subset$dest)

# create the network visualization
visNetwork(nodes, edges, width = "100%") %>%
  visNodes(shape = "dot", size = 10) %>%
  visEdges(arrows = "to", smooth = TRUE) %>%
  visLayout(randomSeed = 123) 

```


## diagramR
```{r}
library(DiagrammeR)

grViz("
digraph {
  
  # Set node defaults
  node [shape = ellipse, style = filled, color = skyblue, fontname = 'Helvetica']

  # Add nodes to the graph
  A [label = 'Gene A']
  B [label = 'Gene B']
  C [label = 'Gene C']
  D [label = 'Gene D']
  E [label = 'Gene E']
  F [label = 'Gene F']
  G [label = 'Gene G']
  H [label = 'Gene H']
  I [label = 'Gene I']
  J [label = 'Gene J']
  K [label = 'Gene K']
  L [label = 'Gene L']
  M [label = 'Gene M']
  N [label = 'Gene N']
  
  # Set edge defaults
  edge [color = red]

  # Add edges to the graph
  A -> B
  A -> C
  B -> D
  C -> D
  C -> E
  D -> F
  E -> F
  F -> G
  F -> H
  G -> I
  H -> I
  I -> J
  I -> K
  J -> L
  K -> L
  L -> M
  L -> N
}
")


```


dygraphs: This package provides interactive and customizable time series plots that can handle large datasets. 
```{r}
#install.packages("dygraphs")
library(dygraphs)
data(co2)
dygraph(co2, main = "Atmospheric CO2 Concentrations") %>%
  dySeries("V1") %>% #specify which series (column) in the data frame to plot in the dygraph()
  dyRangeSelector()


```

pca
```{r}

pca <- prcomp(t(exprs(TCGA_eset)), scale. = TRUE)

# Plot the PCA
ggplot(as.data.frame(pca$x), aes(x = PC1, y = PC2)) +
  geom_point() +
  xlab(paste0("PC1: ", round(summary(pca)$importance[2, 1] * 100, 1), "%")) +
  ylab(paste0("PC2: ", round(summary(pca)$importance[2, 2] * 100, 1), "%")) +
  theme_bw()


```


```{r}
# You will need a differential gene expression analysis result for this
# Here, I'm using a mock data frame
logFC <- rnorm(nrow(TCGA_eset), mean = 0, sd = 1)
A_value <- rowMeans(exprs(TCGA_eset))
M_value <- logFC

ma_data <- data.frame(Gene = rownames(TCGA_eset),
                      A_value = A_value,
                      M_value = M_value)

ggplot(ma_data, aes(x = A_value, y = M_value)) +
  geom_point(alpha = 0.5) +
  xlab("A - Mean Expression") +
  ylab("M - log Fold Change") +
  theme_bw()

```

```{r}
#BiocManager::install("mixOmics")
library(mixOmics)

# Randomly select 100 samples
set.seed(42)  # Set seed for reproducibility
selected_samples <- sample(colnames(TCGA_eset), 100)

# Subset the data
TCGA_eset_subset <- TCGA_eset[, selected_samples]

# PCA plot
pca_res <- pca(t(exprs(TCGA_eset_subset)), ncomp = 2)
plotIndiv(pca_res)

```

